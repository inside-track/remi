# This is an example Remi job that was auto-generated by Remi.
require_relative 'all_jobs_shared'
require 'remi/data_subjects/salesforce'

class SampleJob < AllJobsShared

  param :program_name_lookup do
    RegexSieve.new(
      {
        /^BIO$/              => "Biology",
        /^Fake Biology$/     => nil,
        /(?:B|Microb)iology/ => "Biology",
        /^CHEM$/             => "Chemistry",
        /Chemistry/          => "Chemistry",
        /Physics/            => "Physics"
      }
    )
  end

  source :existing_contacts do
    extractor Remi::Extractor::Salesforce.new(
      object: :Contact,
      credentials: params[:salesforce_credentials],
      api: :bulk,
      query: <<-EOQ
        SELECT
          Id,
          External_ID__c,
          IsActive,
          CreatedDate
        FROM
          Contact
      EOQ
    )
    parser Remi::Parser::Salesforce.new

    field_symbolizer :salesforce
    fields(
      {
        :Id             => {},
        :External_ID__c => {},
        :IsActive       => { type: :boolean },
        :CreatedDate    => { type: :date, in_format: '%Y-%m-%d %H:%M:%S' }
      }
    )
  end

  source :sample_file do
    extractor Remi::Extractor::SftpFile.new(
      credentials: params[:sftp],
      remote_path: '/',
      pattern: /^SampleFile_(\d+)\.txt/,
      most_recent_only: true
    )

    parser Remi::Parser::CsvFile.new(
      csv_options: {
        headers: true,
        col_sep: ",",
        encoding: "ISO-8859-1:UTF-8"
      }
    )

    fields(
      {
        :student_id             => {},
        :school_id              => {},
        :school_name            => {},
        :program                => {},
        :last_name              => {},
        :first_name             => {},
        :current_email          => {},
        :mailing_address_line_1 => {},
        :mailing_address_line_2 => {},
        :mailing_city           => {},
        :mailing_state          => {},
        :mailing_postal_code    => {},
        :birthdate              => { type: :date, in_format: '%m/%d/%Y'},
        :applied_date           => { type: :date, in_format: '%m/%d/%Y'}
      }
    )
  end


  target :all_contacts

  target :contact_updates do
    encoder Remi::Encoder::Salesforce.new
    loader Remi::Loader::Salesforce.new(
      credentials: params[:salesforce_credentials],
      object: :Contact,
      operation: :update,
      api: :bulk
    )
    field_symbolizer :salesforce
  end

  target :contact_creates do
    encoder Remi::Encoder::Salesforce.new
    loader Remi::Loader::Salesforce.new(
      credentials: params[:salesforce_credentials],
      object: :Contact,
      operation: :create,
      api: :bulk
    )
    field_symbolizer :salesforce
  end


  transform :map_common_fields do
    # Exclude all source records with an invalid program name
    all_contacts.df = sample_file.df.dup
    Remi::SourceToTargetMap.apply(all_contacts.df) do
      map source(:program) .target(:Major__c)
        .transform(Remi::Transform::Lookup.new(job.params[:program_name_lookup]))
    end
    all_contacts.df = all_contacts.df.where(all_contacts.df[:Major__c].not_eq(nil))

    student_id_to_sf_id = existing_contacts.df.map_rows { |row| [row[:External_ID__c], row[:Id]] }.to_h

    # Map fields that are common to both creates and updates
    Remi::SourceToTargetMap.apply(all_contacts.df) do

      # Prefixes source id record and then looks up existing salesforce Id
      prefixer = Remi::Transform::Prefix.new('SAMP')
      map source(:student_id) .target(:External_ID__c, :Id)
        .transform(->(row) {
          row[:External_ID__c] = prefixer.call(row[:student_id])
          row[:Id] = student_id_to_sf_id[row[:External_ID__c]]
        })
    end
  end


  transform :map_creates do
    work_contact_creates = all_contacts.df.where(all_contacts.df[:Id].eq(nil))

    Remi::SourceToTargetMap.apply(work_contact_creates) do

      map source(:school_id)           .target(:School_ID__c)

      map source(:school_name)         .target(:School_Name__c)
      map source(:first_name)          .target(:FirstName)
        .transform(Remi::Transform::IfBlank.new('Not Provided'))
      map source(:last_name)           .target(:LastName)
        .transform(Remi::Transform::IfBlank.new('Not Provided'))
      map source(:mailing_city)        .target(:MailingCity)
      map source(:mailing_state)       .target(:MailingState)
      map source(:mailing_postal_code) .target(:MailingPostalCode)

      map source(:birthdate)                  .target(:Birthdate)
        .transform(Remi::Transform::FormatDate.new(in_format: sample_file.fields[:birthdate][:in_format]))

      map source(:applied_date)              .target(:Applied_Date__c)
        .transform(Remi::Transform::IfBlank.new(Date.today.strftime(sample_file.fields[:applied_date][:in_format])))
        .transform(Remi::Transform::FormatDate.new(in_format: sample_file.fields[:applied_date][:in_format]))

      map source(:mailing_address_line_1, :mailing_address_line_2) .target(:MailingStreet)
        .transform(->(row) {
          if row[:mailing_address_line_1].blank?
            ''
          else
            [row[:mailing_address_line_1], row[:mailing_address_line_2]].join(', ')
          end
        })

      if_blank_unknown = Remi::Transform::IfBlank.new("Unknown")
      map source(:school_id, :school_name) .target(:School__c)
        .transform(->(row) {
          row[:school_id] = if_blank_unknown.call(row[:school_id])
          row[:school_name] = if_blank_unknown.call(row[:school_name])
        })
        .transform(Remi::Transform::Concatenate.new('-'))

      map source(:current_email)       .target(:Email)
        .transform(Remi::Transform::Replace.new(/,/, '.'))
        .transform(Remi::Transform::ValidateEmail.new)
    end

    contact_creates.df = work_contact_creates[
      :External_ID__c,
      :School_ID__c,
      :School_Name__c,
      :School__c,
      :Major__c,
      :FirstName,
      :LastName,
      :Email,
      :MailingStreet,
      :MailingCity,
      :MailingState,
      :MailingPostalCode,
      :Birthdate,
      :Applied_Date__c
    ]
  end

  transform :map_updates do
    contact_updates.df = all_contacts.df[
      :Id,
      :Major__c
    ].where(all_contacts.df[:Id].not_eq(nil))
  end
end
